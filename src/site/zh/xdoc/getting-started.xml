<?xml version="1.0" encoding="UTF-8"?>
<!--
  Copyright 2010-2012 the original author or authors.

  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
-->

<!-- version: $Id$ -->

<document xmlns="http://maven.apache.org/XDOC/2.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://maven.apache.org/XDOC/2.0 http://maven.apache.org/xsd/xdoc-2.0.xsd">

  <properties>
    <title>MyBatis 3 | 入门</title>
    <author email="clinton.begin@gmail.com">Clinton Begin</author>
    <author email="nanlei1987@gmail.com">Nan Lei</author>
    <author email="echowdx@gmail.com">Dongxu Wang</author>
  </properties>

  <body>
    <section name="入门">
    
    <subsection name="安装">
      <p>想要使用 MyBatis 只需将 <code>mybatis-x.x.x.jar</code> 文件置于 classpath 中。</p>
      <p>如果使用 Maven 构建项目，则需将下面的 dependency 置于 pom.xml 中：</p>
        <source><![CDATA[
<dependency>
  <groupId>org.mybatis</groupId>
  <artifactId>mybatis</artifactId>
  <version>x.x.x</version>
</dependency>]]></source>
    </subsection>    
    
    <subsection name="从 XML 中构建 SqlSessionFactory">
      <p>每个基于 MyBatis 的应用都是以一个 SqlSessionFactory 的实例为中心的。SqlSessionFactory 的实例可以通过 SqlSessionFactoryBuilder 获得。SqlSessionFactoryBuilder 可以从 XML 配置文件或一个预先定制的 Configuration 的实例构建出 SqlSessionFactory 的实例。</p>
      <p>从 XML 文件中构建 SqlSessionFactory 的实例非常简单，建议使用类路径下的资源文件进行配置。但是也可以使用任意的 InputStream 实例，包括字符串形式或 URL 形式的文件路径来配置。MyBatis 包含一个叫 Resources 的工具类，它包含一些静态方法，可使从 classpath 或其他位置加载资源文件更容易。</p>
      <source><![CDATA[
String resource = "org/mybatis/example/mybatis-config.xml";
InputStream inputStream = Resources.getResourceAsStream(resource);
sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);]]></source>
      <p>XML 配置文件（configuration XML）中包含了对 MyBatis 系统的核心设置，包含获取数据库连接实例的数据源（DataSource）和决定事务范围和控制方式的事务管理器（TransactionManager）。XML 配置文件的详细内容后面再探讨，这里先给出一个简单的示例：</p>
      <source><![CDATA[<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE configuration
  PUBLIC "-//mybatis.org//DTD Config 3.0//EN"
  "http://mybatis.org/dtd/mybatis-3-config.dtd">
<configuration>
  <environments default="development">
    <environment id="development">
      <transactionManager type="JDBC"/>
      <dataSource type="POOLED">
        <property name="driver" value="${driver}"/>
        <property name="url" value="${url}"/>
        <property name="username" value="${username}"/>
        <property name="password" value="${password}"/>
      </dataSource>
    </environment>
  </environments>
  <mappers>
    <mapper resource="org/mybatis/example/BlogMapper.xml"/>
  </mappers>
</configuration>]]></source>
      <p>当然，XML 配置文件中还有很多可以配置的，上面的示例指出的则是最关键的部分。要注意 XML 头部的声明，需要用来验证 XML 文档正确性。environment 元素体中包含了事务管理和连接池的环境配置。mappers 元素是包含一组 mapper 映射器（这些 mapper的 XML 文件包含了 SQL 代码和映射定义信息）。</p>
    </subsection>
    <subsection name="不使用 XML 构建 SqlSessionFactory">
      <p>如果你更愿意直接从 Java 程序而不是 XML 文件中创建配置，或创建你自己的配置构建器，MyBatis 也提供了完整的配置类，具有所有和 XML 文件相同功能的配置项。</p>
      <source><![CDATA[DataSource dataSource = BlogDataSourceFactory.getBlogDataSource();
TransactionFactory transactionFactory = new JdbcTransactionFactory();
Environment environment = new Environment("development", transactionFactory, dataSource);
Configuration configuration = new Configuration(environment);
configuration.addMapper(BlogMapper.class);
SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(configuration);]]></source>
      <p>注意该例中配置添加了一个映射类（mapper class）。映射类是 Java 类，它们包含 SQL 映射语句的注解从而避免了 XML 文件的依赖，不过，由于 Java 注解的一些限制加之某些 MyBatis 映射的复杂性，XML 映射对于大多数高级映射（比如：嵌套 Join 映射）来说仍然是必须的。鉴于此，如果存在一个对等的 XML 配置文件的话，MyBatis 会自动查找并加载它（这种情况下， BlogMapper.xml 将会基于类路径和 BlogMapper.class 的类名被加载进来）。具体细节稍后继续。</p>
    </subsection>
    <subsection name="从 SqlSessionFactory 中获取 SqlSession">
      <p>既然有了 SqlSessionFactory ，顾名思义，我们就可以从中获得 SqlSession 的实例了。SqlSession 完全包含了面向数据库执行 SQL 命令所需的所有方法。你可以通过 SqlSession 实例来直接执行已映射的 SQL 语句。例如：</p>
      <source><![CDATA[SqlSession session = sqlSessionFactory.openSession();
try {
  Blog blog = (Blog) session.selectOne("org.mybatis.example.BlogMapper.selectBlog", 101);
} finally {
  session.close();
}]]></source>
      <p>诚然这种方式能够正常工作，并且对于之前版本 MyBatis 的用户来说也比较熟悉，不过现在有了一种更直白的方式。通过使用对于给定语句能够合理描述参数和返回值的接口（比如说BlogMapper.class），你现在不但可以执行更清晰和类型安全的代码，而且还不用担心易错的字符串字面值以及强制类型转换。</p>
      <p>例如：</p>
      <source><![CDATA[SqlSession session = sqlSessionFactory.openSession();
try {
  BlogMapper mapper = session.getMapper(BlogMapper.class);
  Blog blog = mapper.selectBlog(101);
} finally {
  session.close();
}]]></source>
      <p>现在我们来探究一下这里到底是怎么执行的。</p>
    </subsection>
    <subsection name="探究已映射的 SQL 语句">
      <p>到这里你或许很想知道 SqlSession 和 Mapper 到底执行了什么操作，而 SQL 映射是个相当大的话题，可能会占去文档的大部分篇幅。不过为了让你能够了解个大概，这里会给出几个如何运行的例子。</p>
      <p>在上面提到的两个例子中，语句应该是一个通过 XML 定义，一个通过注解定义。先看 XML 定义这个，事实上 MyBatis 提供的全部特性可以利用基于 XML 的映射语言来实现，这使得 MyBatis 在过去的数年间得以流行。如果你以前用过 MyBatis，这个概念应该会比较熟悉。不过 XML 映射文件已经有了很多的改进，随着文档的进行会愈发清晰。这里给出一个基于 XML 映射语句的示例，它应该可以满足上述示例中 SqlSession 的调用。</p>
      <source><![CDATA[<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper
  PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
  "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="org.mybatis.example.BlogMapper">
  <select id="selectBlog" resultType="Blog">
    select * from Blog where id = #{id}
  </select>
</mapper>]]></source>
      <p>对于这个简单的例子来说似乎有点小题大做了，但实际上它是非常轻量的。在一个 XML 映射文件中，你想定义多少个映射语句都是可以的，这样下来，XML 头部和文件类型声明占去的部分就显得微不足道了。文件的剩余部分具有很好的自解释性。在命名空间“com.mybatis.example.BlogMapper”中定义了一个名为“selectBlog”的映射语句，这样它就允许你使用指定的完全限定名“org.mybatis.example.BlogMapper.selectBlog”来调用映射语句，就像上面的例子中做的那样：</p>
      <source><![CDATA[Blog blog = (Blog) session.selectOne("org.mybatis.example.BlogMapper.selectBlog", 101);]]></source>
      <p>
要注意这个使用完全限定名调用 Java 对象的方法是相似的,这样做是有原因的。这个
命名可以直接给相同命名空间下的的映射类,
使用一个名称,
参数和返回值和已映射的查询
语句都一样的方法即可。
这就允许你非常容易地调用映射器接口中的方法,
这和你前面看到
的是一样的,下面这个示例中它又出现了。
      </p>
      <source><![CDATA[BlogMapper mapper = session.getMapper(BlogMapper.class);
Blog blog = mapper.selectBlog(101);]]></source>
      <p>
第二种方式有很多优点,首先它不是基于文字的,那就更安全了。第二,如果你的 IDE
有代码补全功能,那么你可以利用它来操纵已映射的 SQL 语句。第三,不需要强制类型转
换,同时 BlogMapper 接口可以保持简洁,返回值类型很安全(参数类型也很安全)
。    </p>
      <hr/>
      <p>
        <span class="label important">重要</span>
        <strong>命名空间的一点注释</strong>
      </p>
      <p>
        <strong>命名空间</strong>
在之前版本的 MyBatis 中是可选项,非常混乱也没有帮助。现在,命名空间
是必须的,而且有一个目的,它使用更长的完全限定名来隔离语句。
      </p>
      <p>
命名空间使得接口绑定成为可能,就像你看到的那样,如果之前不了解,那么现在你
就会使用它们了,你应该按照下面给出示例的来练习,以免改变自己的想法。使用命名空
间,并将它放在合适的 Java 包空间之下,将会使你的代码变得简洁,在很长的时间内提高
MyBatis 的作用。
      </p>
      <p>
        <strong>命名解析:</strong> 为了减少输入量,MyBatis 对所有的命名配置元素使用如下的命名解析规
则,包括语句,结果映射,缓存等。
      </p>
      <ul>
        <li>直接查找完全限定名(比如“com.mypackage.MyMapper.selectAllThings”,如果
) 发现就使用。
        </li>
        <li>短名称(比如“selectAllThings”
)可以用来引用任意含糊的对象。而如果有两个
或两个以上的(比如“com.foo.selectAllThings ”和“com.bar.selectAllThings”
), 那么就会得到错误报告,说短名称是含糊的,因此就必须使用完全限定名。
        </li>
      </ul>
      <hr/>
      <p>
如 BlogMapper 这样的映射器类来说,还有一个妙招。它们中间映射的语句可以不需要
在 XML 中来写,而可以使用 Java 注解来替换。比如,上面的 XML 示例可以如下来替换:
      </p>
      <source><![CDATA[package org.mybatis.example;
public interface BlogMapper {
  @Select("SELECT * FROM blog WHERE id = #{id}")
  Blog selectBlog(int id);
}]]></source>
      <p>
对于简单语句来说,使用注解代码会更加清晰,然而 Java 注解对于复杂语句来说就会
混乱,
应该限制使用。
因此,
如果你不得不做复杂的事情,
那么最好使用 XML 来映射语句。
      </p>
      <p>
当然这也取决于你和你的项目团队的决定,
看哪种更适合你来使用,
还有以长久方式来
使用映射语句的重要性。也就是说,不要将自己局限在一种方式中。你可以轻松地将注解换
成 XML 映射语句,反之亦然。
      </p>
    </subsection>
    <subsection name="范围和生命周期">
      <p>
理解我们目前已经讨论过的不同范围和生命周期类是很重要的。
不正确的使用它们会导
致严重的并发问题。
      </p>
      <hr/>
      <p><span class="label important">重要</span>
        <strong>Object lifecycle and Dependency Injection Frameworks</strong>
      </p>
      <p>
        Dependency Injection frameworks can create thread safe, transactional SqlSessions and mappers 
        and inject them directly into your beans so you can just forget about their lifecycle. 
        You may want to have a look at MyBatis-Spring or
        MyBatis-Guice sub-projects to know more about using MyBatis with DI frameworks.
      </p>
      <hr/>
      <h4>SqlSessionFactoryBuilder</h4>
        <p>
这个类可以被实例化,使用和丢弃。一旦你创建了 SqlSessionFactory 后,这个类就不需
要存在了。
因此 SqlSessionFactoryBuilder 实例的最佳范围是方法范围
(也就是本地方法变量)。
你可以重用 SqlSessionFactoryBuilder 来创建多个 SqlSessionFactory 实例,
但是最好的方式是
不需要保持它一直存在来保证所有 XML 解析资源,因为还有更重要的事情要做。
        </p>
      <h4>SqlSessionFactory</h4>
        <p>
一旦被创建,SqlSessionFactory 应该在你的应用执行期间都存在。没有理由来处理或重
新创建它。
使用 SqlSessionFactory 的最佳实践是在应用运行期间不要重复创建多次。
这样的
操作将被视为是非常糟糕的。
因此 SqlSessionFactory 的最佳范围是应用范围。
有很多方法可
以做到,
最简单的就是使用单例模式或者静态单例模式。
        </p>
      <h4>SqlSession</h4>
        <p>
每个线程都应该有它自己的 SqlSession 实例。SqlSession 的实例不能被共享,也是线程
不安全的。因此最佳的范围是请求或方法范围。绝对不能将 SqlSession 实例的引用放在一个
类的静态字段甚至是实例字段中。
也绝不能将 SqlSession 实例的引用放在任何类型的管理范
围中,
比如 Serlvet 架构中的 HttpSession。
如果你现在正用任意的 Web 框架,
要考虑 SqlSession
放在一个和 HTTP 请求对象相似的范围内。换句话说,基于收到的 HTTP 请求,你可以打开
了一个 SqlSession,然后返回响应,就可以关闭它了。关闭 Session 很重要,你应该确保使
用 finally 块来关闭它。下面的示例就是一个确保 SqlSession 关闭的基本模式:
        </p>
        <source><![CDATA[SqlSession session = sqlSessionFactory.openSession();
try {
  // do work
} finally {
  session.close();
}]]></source>
        <p>
在你的代码中一贯地使用这种模式,
将会保证所有数据库资源都正确地关闭
(假设你没
有通过你自己的连接关闭,这会给 MyBatis 造成一种迹象表明你要自己管理连接资源)
。        </p>
      <h4>Mapper 实例</h4>
        <p>
映射器是你创建绑定映射语句的接口。映射器接口的实例可以从 SqlSession 中获得。那
么从技术上来说,当被请求时,任意映射器实例的最宽范围和 SqlSession 是相同的。然而,
映射器实例的最佳范围是方法范围。也就是说,它们应该在使用它们的方法中被请求,然后
就抛弃掉。它们不需要明确地关闭,那么在请求对象中保留它们也就不是什么问题了,这和
SqlSession 相似。你也许会发现,在这个水平上管理太多的资源的话会失控。保持简单,将
映射器放在方法范围内。下面的示例就展示了这个实践:
        </p>
        <source><![CDATA[SqlSession session = sqlSessionFactory.openSession();
try {
  BlogMapper mapper = session.getMapper(BlogMapper.class);
  // do work
} finally {
  session.close();
}
]]></source>

      </subsection>
    </section>
  </body>
</document>
